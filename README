EM::RemoteCall provides an Eventmachine server/client couple which allows the client to call methods within the server process. Local callbacks on the client are supported.

The most usual case is the following: You have a Book class on the client and the server. Then the client wants to call methods on Book instances on the server. In order to make this work, the servers Book class has to provide a method to identify its instances. ORMs do that via an ID and a .find class method. The is_a_collection gem (https://rubygems.org/gems/is_a_collection) provides similar functionality for non-ORM classes. The call the client makes looks like this:

  {:opts => method_opts, :instance => {:class => klass, :id => id}, :method => remote_method}

or

That means, if the client has a book instance @book with the id 1234 and calls #read on it:

  @book.read 'fast'

the call is sent to the server like this:

  {:opts => 'fast', :instance => {:class => Book, :id => 1234}, :method => 'read'}

and this gets executed on the server:

  Book.find(1234).read('fast')

:opts can be anything that JSON encodable and parseable. Namely Strings, Numbers, Arrays and Hashes.

EM::RemoteCall supports callbacks. So when you call the method on the client with a block given, the block get's stored on the client for later execution. Note that it doesn't go over the wire. While this would technically be possible, there are some issues with it. When the method on the server takes a block, the callback on the client will get triggered as soon as the block on the server is called. Example:

On the client

  @book.read('fast'){puts 'finished'}

then proc{puts 'finished'} get's stored for later execution, referenced by a callback id. This goes over the wire:

  {:opts => 'fast', :instance => {:class => Book, :id => 1234}, :method => 'read', :callback_id => 5678}

Now this gets executed on the server:

  Book.find(1234).read('fast'){ send_data({:callback_id => 5678}) }

As soon, as the block of #read is called on the server, this message goes back over the wire to the client:

  {:callback_id => 5678}

and this in turn triggers the execution of the formerly stored callback on the client.

A special case are class methods. In the wire protocol they are just identified by :instance => {:id => nil}. In the definition just skip the :find_by parameter.

Return values of remote methods and arguments to callback are supported, too. See specs for further examples.

= TODO

* more specs (at the moment there are no unit spec, but just integration specs)
